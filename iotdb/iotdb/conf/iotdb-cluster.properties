#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#

# Cluster node: {ip1:port,ip2:port,...,ipn:port}
nodes = 127.0.0.1:8888

# number of data replicator
replication = 1

# Local ip. If the cluster is deployed with more than one ip,
# the parameter should be set to the real IP address rather than 127.0.0.1.
ip = 127.0.0.1

port = 8888

#raft_log_path = /tmp/raft/log/

#raft_snapshot_path = /tmp/raft/snapshot/

#raft_metadata_path = /tmp/raft/metadata/


# A follower would become a candidate if it doesn't receive any message
# from the leader in election_timeout_ms milliseconds
election_timeout_ms = 1000

# When the number of the difference between leader and follower log is less than this value, it
# is considered as 'catch-up'
max_catch_up_log_num = 100000

# Whether to enable the delayed snapshot mechanism or not
delay_snapshot = false

# Maximum allowed delay hours of snapshot
delay_hours = 2

# When a node receives a request from client, if it finds itself unable to process the request,
# then it sends requests to other nodes in the cluster.
# This parameter represents the maximum count to redo the request.
qp_task_redo_count = 10

# When a node receives a request from client, if it finds itself unable to process the request,
# then it sends requests to other nodes in the cluster.
# This parameter represents the maximum timeout for these requests. The unit is milliseconds.
qp_task_timeout_ms = 1000

# number of virtual nodes
num_of_virtual_nodes = 2

# Maximum number of use inner rpc client
max_num_of_inner_rpc_client = 500

# Maximum number of queue length to use inner rpc client, the request which exceed to this
# number will be rejected.
max_queue_num_of_inner_rpc_client = 500

# ReadMetadataConsistencyLevel: 1  Strong consistency, 2  Weak consistency
read_metadata_consistency_level = 1

# ReadDataConsistencyLevel: 1  Strong consistency, 2  Weak consistency
read_data_consistency_level = 1

# Maximum number of threads which execute tasks generated by client requests concurrently.
# Each client request corresponds to a QP Task. A QP task may be divided into several sub-tasks.
# So this value is the sum of all sub-tasks.
# When this value <= 0, use CPU core number * 10
concurrent_qp_sub_task_thread = 0

# For each raft log, its state machine will start a thread to apply this log.
# This value indicates maximum number of threads for a state machine to create.
# Currently, this param only works for state machine of leader in data partition holder.
# Staten machine in metadata holder will apply raft log serially.
# When this value <= 0, use CPU core number.
concurrent_raft_task_thread = 0

# Maximum time of blocking main thread for waiting for all running task threads and tasks in the
# queue until end. The unit is milliseconds.
# Each client request corresponds to a QP Task. A QP task may be divided into several sub-tasks.
close_qp_sub_task_block_timeout = 1000

# Maximum time of blocking main thread for waiting for all running task threads and tasks in the
# queue until end. The unit is milliseconds.
# Raft Task refers to tasks that need to be performed in the state machine.
# Due to guarantee data consistency, it must ensure that raft tasks finish.
# If user sets the parameter, it will not sure to guarantee consistency.
close_raft_task_block_timeout = 0