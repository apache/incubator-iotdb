<!--

    Licensed to the Apache Software Foundation (ASF) under one
    or more contributor license agreements.  See the NOTICE file
    distributed with this work for additional information
    regarding copyright ownership.  The ASF licenses this file
    to you under the Apache License, Version 2.0 (the
    "License"); you may not use this file except in compliance
    with the License.  You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing,
    software distributed under the License is distributed on an
    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, either express or implied.  See the License for the
    specific language governing permissions and limitations
    under the License.

-->

# Query Result Set Header Construction

## Introduction

This text will introduce the result set header construction way of RawDataQuery, AlignByDeviceQuery and LastQuery. e.g. DownsamplingQuery and FillQuery etc. will be introduced as subquery in these three queries.

## Raw data query

The header construction logic of raw data query is in the `getWideQueryHeaders()` method.

- org.apache.iotdb.db.service.TSServiceImpl.getWideQueryHeaders

For the construction of each header, you need to provide the column name and the corresponding data type of the column.

- Ordinary raw data query (including FillQuery) only needs to obtain timeseries paths **not de duplicated** from the physical query plan, which are the column names, and use these paths to obtain the corresponding data type to generate the result set header.

- If the raw data query contains aggregate functions (including AggregateQuery and DownsamplingQuery), the time column will be ignored and **aggregate function and timeseries path will be combined to form the column name**, and when obtaining the data type, the type of aggregate function will prevail. For example, `root.sg.d1.s1` is of FLOAT type, while `count(root.sg.d1.s1)` shoule be of INT type.

Next, we will give examples：

Assuming that all timeseries in the query below exist, the result set headers generated by the following two queries are respectively:

SQL1：`SELECT s1, s2 FROM root.sg.d1;`  ->

| Time | root.sg.d1.s1 | root.sg.d1.s2 |
| ---- | ------------- | ------------- |
|      |               |               |

SQL2：`SELECT count(s1), max_time(s1) FROM root.sg.d1;` ->

| count(root.sg.d1.s1) | max_time(root.sg.d1.s2) |
| -------------------- | ----------------------- |
|                      |                         |

## Align by device query

The header construction logic of align by device query is in the `getAlignByDeviceQueryHeaders()` method.

- org.apache.iotdb.db.service.TSServiceImpl.getAlignByDeviceQueryHeaders

The result set construction of the AlignByDeviceQuery depends on the list of **measurements not de duplicated** generated in the physical query plan. For a brief introduction, the measurements list is a list generated by the suffix path (including wildcards) in the SELECT clause, including three types, namely constant, exist and nonexist. For details, please refer to [Align by device query](/SystemDesign/5-DataQuery/8-AlignByDeviceQuery.html)

Since the structure of relation table is used for AlignByDeviceQuery, the device column is added to the header first, and its corresponding data type is text type.

Then get the list of measurements, take each measurement as the column name, and get the corresponding data type depending on the measurements' type. If it is a Constant or NonExist type, the data type is directly set as Text type. If it's an Exist type, then get the corresponding type from the `measurementdatatypemap`, which is stored in the physical query plan.

Note that in the case of an AggregationQuery, the measuremnts in the list here will contain aggregate functions, so they can be processed together.

Next, we will give an example：

Assuming there are two timeseries now: `root.sg.d1.s1`, `root.sg.d1.s2`， then the result set header generated by the query below is:

SQL：`SELECT '111', s1, s2, *, s5 FROM root.sg.d1 ALIGN BY DEVICE;`

-> measurements list: ['111', s1, s2, s1, s2, s5]

-> header

| Time | Device | 111 | s1  | s2  | s1  | s2  | s5  |
| ---- | ------ | --- | --- | --- | --- | --- | --- |
|      |        |     |     |     |     |     |     |

## LastQuery

The header construction logic of last query is in the static method `LAST_RESP`.

- org.apache.iotdb.db.service.StaticResps.LAST_RESP

The latest data query calculates the result with the largest timestamp of the timeseries to be queried and displays it in three columns: time, timeseries and the corresponding value.

Next, we will give an example：

Assuming there are two timeseries now: `root.sg.d1.s1`, `root.sg.d1.s2`， then the result set header generated by the query below is:

SQL：`SELECT last s1, s2 FROM root.sg.d1;`

| Time | timeseries    | value |
| ---- | ------------- | ----- |
| ...  | root.sg.d1.s1 | ...   |
| ...  | root.sg.d1.s2 | ...   |
